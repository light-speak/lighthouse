// Code generated by github.com/light-speak/lighthouse, DO NOT EDIT.
package models




type SearchableAnalyzer int8

const (
  // Maximum word segmentation, splits into as many possible terms as possible
  SearchableAnalyzerIK_MAX_WORD = iota
  // Smart word segmentation, splits into more commonly used terms
  SearchableAnalyzerIK_SMART
)

func (e SearchableAnalyzer) ToString() string {
  switch e {
  case SearchableAnalyzerIK_MAX_WORD:
    return "IK_MAX_WORD"
  case SearchableAnalyzerIK_SMART:
    return "IK_SMART"
  default:
    return "unknown"
  }
}

var SearchableAnalyzerMap = map[string]SearchableAnalyzer{
  "IK_MAX_WORD": SearchableAnalyzerIK_MAX_WORD,
  "IK_SMART": SearchableAnalyzerIK_SMART,
}
type SearchableType int8

const (
  // For boolean values, represents true or false
  SearchableTypeBOOLEAN = iota
  // For byte values, such as flags
  SearchableTypeBYTE
  // For date and time, supports multiple date formats, default is ISO 8601
  SearchableTypeDATE
  // For double precision floating point numbers, such as precise financial calculations
  SearchableTypeDOUBLE
  // For single precision floating point numbers, such as general scientific calculations
  SearchableTypeFLOAT
  // For half precision floating point numbers, such as simple graphics processing
  SearchableTypeHALF_FLOAT
  // For integer values, such as age, quantity
  SearchableTypeINTEGER
  // For storing IPv4 or IPv6 addresses
  SearchableTypeIP
  // For exact matching, suitable for user IDs, status, etc.
  SearchableTypeKEYWORD
  // For long integer values, such as timestamps
  SearchableTypeLONG
  // For scaled floating point numbers, such as amounts requiring precise decimal control
  SearchableTypeSCALED_FLOAT
  // For short integer values, such as small range enums
  SearchableTypeSHORT
  // For full-text search, suitable for article content, descriptions, etc.
  SearchableTypeTEXT
)

func (e SearchableType) ToString() string {
  switch e {
  case SearchableTypeBOOLEAN:
    return "BOOLEAN"
  case SearchableTypeBYTE:
    return "BYTE"
  case SearchableTypeDATE:
    return "DATE"
  case SearchableTypeDOUBLE:
    return "DOUBLE"
  case SearchableTypeFLOAT:
    return "FLOAT"
  case SearchableTypeHALF_FLOAT:
    return "HALF_FLOAT"
  case SearchableTypeINTEGER:
    return "INTEGER"
  case SearchableTypeIP:
    return "IP"
  case SearchableTypeKEYWORD:
    return "KEYWORD"
  case SearchableTypeLONG:
    return "LONG"
  case SearchableTypeSCALED_FLOAT:
    return "SCALED_FLOAT"
  case SearchableTypeSHORT:
    return "SHORT"
  case SearchableTypeTEXT:
    return "TEXT"
  default:
    return "unknown"
  }
}

var SearchableTypeMap = map[string]SearchableType{
  "BOOLEAN": SearchableTypeBOOLEAN,
  "BYTE": SearchableTypeBYTE,
  "DATE": SearchableTypeDATE,
  "DOUBLE": SearchableTypeDOUBLE,
  "FLOAT": SearchableTypeFLOAT,
  "HALF_FLOAT": SearchableTypeHALF_FLOAT,
  "INTEGER": SearchableTypeINTEGER,
  "IP": SearchableTypeIP,
  "KEYWORD": SearchableTypeKEYWORD,
  "LONG": SearchableTypeLONG,
  "SCALED_FLOAT": SearchableTypeSCALED_FLOAT,
  "SHORT": SearchableTypeSHORT,
  "TEXT": SearchableTypeTEXT,
}
type SortOrder int8

const (
  // Ascending order
  SortOrderASC = iota
  // Descending order
  SortOrderDESC
)

func (e SortOrder) ToString() string {
  switch e {
  case SortOrderASC:
    return "ASC"
  case SortOrderDESC:
    return "DESC"
  default:
    return "unknown"
  }
}

var SortOrderMap = map[string]SortOrder{
  "ASC": SortOrderASC,
  "DESC": SortOrderDESC,
}
