// Code generated by github.com/light-speak/lighthouse, DO NOT EDIT.
package repo

import (
  "github.com/light-speak/lighthouse/context"
  "sync"
  "github.com/light-speak/lighthouse/utils"
  "works/models"
  "gorm.io/gorm"
  "github.com/light-speak/lighthouse/graphql/model"
)

// Generic loader function
func loadEntity[T any](ctx *context.Context, key int64, table string, field string, filters ...*model.Filter) (*sync.Map, error) {
  data, err := model.GetLoader[int64](model.GetDB(), table, field, filters).Load(key)
  if err != nil {
    return nil, err
  }
  return utils.MapToSyncMap(data), nil
}

// Generic list loader function  
func loadEntityList[T any](ctx *context.Context, key int64, table string, field string, filters ...*model.Filter) ([]*sync.Map, error) {
  datas, err := model.GetLoader[int64](model.GetDB(), table, field, filters).LoadList(key)
  if err != nil {
    return nil, err
  }
  return utils.MapSliceToSyncMapSlice(datas), nil
}

// Generic query function
func queryEntity[T any](m interface{}, scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return model.GetDB().Model(m).Scopes(scopes...)
}

// Generic first function
func firstEntity[T any](ctx *context.Context, data *sync.Map, enumFieldsFn func(string) func(interface{}) interface{}, 
  model interface{}, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  
  var err error
  var mu sync.Mutex
  
  if data == nil {
    mapData := make(map[string]interface{})
    err = queryEntity[T](model).Scopes(scopes...).First(&mapData).Error
    if err != nil {
      return nil, err
    }
    data = utils.MapToSyncMap(mapData)
  }

  result := &sync.Map{}
  data.Range(func(key, value interface{}) bool {
    k := key.(string)
    if fn := enumFieldsFn(k); fn != nil {
      mu.Lock()
      result.Store(k, fn(value))
      mu.Unlock()
    } else {
      result.Store(k, value)
    }
    return true
  })
  return result, nil
}

// Generic list function
func listEntity[T any](ctx *context.Context, datas []*sync.Map, enumFieldsFn func(string) func(interface{}) interface{}, model interface{}, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  if datas == nil {
    mapDatas := make([]map[string]interface{}, 0)
    err := queryEntity[T](model).Scopes(scopes...).Find(&mapDatas).Error
    if err != nil {
      return nil, err
    }
    datas = utils.MapSliceToSyncMapSlice(mapDatas)
  }

  var mu sync.Mutex
  results := make([]*sync.Map, len(datas))
  
  for i, data := range datas {
    result := &sync.Map{}
    data.Range(func(key, value interface{}) bool {
      k := key.(string)
      if fn := enumFieldsFn(k); fn != nil {
        mu.Lock()
        result.Store(k, fn(value))
        mu.Unlock()
      } else {
        result.Store(k, value)
      }
      return true
    })
    results[i] = result
  }
  
  return results, nil
}

// Generic count function
func countEntity[T any](model interface{}, scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  var count int64
  err := queryEntity[T](model).Scopes(scopes...).Count(&count).Error
  return count, err
}

// Work functions
func Load__Work(ctx *context.Context, key int64, field string, filters ...*model.Filter) (*sync.Map, error) {
  return loadEntity[models.Work](ctx, key, "works", field, filters...)
}

func LoadList__Work(ctx *context.Context, key int64, field string, filters ...*model.Filter) ([]*sync.Map, error) {
  return loadEntityList[models.Work](ctx, key, "works", field, filters...)
}

func Query__Work(scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return queryEntity[models.Work](&models.Work{}, scopes...)
}

func First__Work(ctx *context.Context, data *sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  return firstEntity[models.Work](ctx, data, models.WorkEnumFields, &models.Work{}, scopes...)
}

func List__Work(ctx *context.Context, datas []*sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  return listEntity[models.Work](ctx, datas, models.WorkEnumFields, &models.Work{}, scopes...)
}

func Count__Work(scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  return countEntity[models.Work](&models.Work{}, scopes...)
}


func init() {
  model.AddQuickFirst("Work", First__Work)
  model.AddQuickList("Work", List__Work)
  model.AddQuickLoad("Work", Load__Work)
  model.AddQuickLoadList("Work", LoadList__Work)
  model.AddQuickCount("Work", Count__Work)
}
