// Code generated by github.com/light-speak/lighthouse, DO NOT EDIT.
package repo

import (
  "example/author/models"
  "sync"
  "github.com/light-speak/lighthouse/utils"
  "github.com/light-speak/lighthouse/graphql/model"
  "github.com/light-speak/lighthouse/context"
  "gorm.io/gorm"
)

// Generic loader function
func loadEntity[T any](ctx *context.Context, key int64, table string, field string, filters ...*model.Filter) (*sync.Map, error) {
  data, err := model.GetLoader[int64](model.GetDB(), table, field, filters).Load(key)
  if err != nil {
    return nil, err
  }
  return utils.MapToSyncMap(data), nil
}

// Generic list loader function  
func loadEntityList[T any](ctx *context.Context, key int64, table string, field string, filters ...*model.Filter) ([]*sync.Map, error) {
  datas, err := model.GetLoader[int64](model.GetDB(), table, field, filters).LoadList(key)
  if err != nil {
    return nil, err
  }
  return utils.MapSliceToSyncMapSlice(datas), nil
}

// Generic query function
func queryEntity[T any](m interface{}, scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return model.GetDB().Model(m).Scopes(scopes...)
}

// Generic first function
func firstEntity[T any](ctx *context.Context, data *sync.Map, enumFieldsFn func(string) func(interface{}) interface{}, 
  model interface{}, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  
  var err error
  var mu sync.Mutex
  
  if data == nil {
    mapData := make(map[string]interface{})
    err = queryEntity[T](model).Scopes(scopes...).First(&mapData).Error
    if err != nil {
      return nil, err
    }
    data = utils.MapToSyncMap(mapData)
  }

  result := &sync.Map{}
  data.Range(func(key, value interface{}) bool {
    k := key.(string)
    if fn := enumFieldsFn(k); fn != nil {
      mu.Lock()
      result.Store(k, fn(value))
      mu.Unlock()
    } else {
      result.Store(k, value)
    }
    return true
  })
  return result, nil
}

// Generic list function
func listEntity[T any](ctx *context.Context, datas []*sync.Map, enumFieldsFn func(string) func(interface{}) interface{}, model interface{}, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  if datas == nil {
    mapDatas := make([]map[string]interface{}, 0)
    err := queryEntity[T](model).Scopes(scopes...).Find(&mapDatas).Error
    if err != nil {
      return nil, err
    }
    datas = utils.MapSliceToSyncMapSlice(mapDatas)
  }

  var mu sync.Mutex
  results := make([]*sync.Map, len(datas))
  
  for i, data := range datas {
    result := &sync.Map{}
    data.Range(func(key, value interface{}) bool {
      k := key.(string)
      if fn := enumFieldsFn(k); fn != nil {
        mu.Lock()
        result.Store(k, fn(value))
        mu.Unlock()
      } else {
        result.Store(k, value)
      }
      return true
    })
    results[i] = result
  }
  
  return results, nil
}

// Generic count function
func countEntity[T any](model interface{}, scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  var count int64
  err := queryEntity[T](model).Scopes(scopes...).Count(&count).Error
  return count, err
}

// Author functions
func Load__Author(ctx *context.Context, key int64, field string, filters ...*model.Filter) (*sync.Map, error) {
  return loadEntity[models.Author](ctx, key, "authors", field, filters...)
}

func LoadList__Author(ctx *context.Context, key int64, field string, filters ...*model.Filter) ([]*sync.Map, error) {
  return loadEntityList[models.Author](ctx, key, "authors", field, filters...)
}

func Query__Author(scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return queryEntity[models.Author](&models.Author{}, scopes...)
}

func First__Author(ctx *context.Context, data *sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  return firstEntity[models.Author](ctx, data, models.AuthorEnumFields, &models.Author{}, scopes...)
}

func List__Author(ctx *context.Context, datas []*sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  return listEntity[models.Author](ctx, datas, models.AuthorEnumFields, &models.Author{}, scopes...)
}

func Count__Author(scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  return countEntity[models.Author](&models.Author{}, scopes...)
}


func init() {
  model.AddQuickFirst("Author", First__Author)
  model.AddQuickList("Author", List__Author)
  model.AddQuickLoad("Author", Load__Author)
  model.AddQuickLoadList("Author", LoadList__Author)
  model.AddQuickCount("Author", Count__Author)
}
