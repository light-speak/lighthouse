type __Schema {
  description: String
  types: [__Type!]!
  queryType: __Type!
  mutationType: __Type
  subscriptionType: __Type
  directives: [__Directive!]!
}

type __Type {
  kind: __TypeKind!
  name: String
  description: String
  fields(includeDeprecated: Boolean = false): [__Field!]
  interfaces: [__Type!]
  possibleTypes: [__Type!]
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  inputFields(includeDeprecated: Boolean = false): [__InputValue!]
  ofType: __Type
  specifiedByURL: String
}

enum __TypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}

type __Field {
  name: String!
  description: String
  args(includeDeprecated: Boolean = false): [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

type __InputValue {
  name: String!
  description: String
  type: __Type!
  defaultValue: String
  isDeprecated: Boolean!
  deprecationReason: String
}

type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

type __Directive {
  name: String!
  description: String
  locations: [__DirectiveLocation!]!
  args(includeDeprecated: Boolean = false): [__InputValue!]!
  isRepeatable: Boolean!
}

enum __DirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
  VARIABLE_DEFINITION
  SCHEMA
  SCALAR
  OBJECT
  FIELD_DEFINITION
  ARGUMENT_DEFINITION
  INTERFACE
  UNION
  ENUM
  ENUM_VALUE
  INPUT_OBJECT
  INPUT_FIELD_DEFINITION
}

type Query {
  __schema: __Schema!
  __type(name: String!): __Type
}


enum SearchableType {
	"For full-text search, suitable for article content, descriptions, etc."
	TEXT
	"For exact matching, suitable for user IDs, status, etc."
	KEYWORD
	"For long integer values, such as timestamps"
	LONG
	"For integer values, such as age, quantity"
	INTEGER
	"For short integer values, such as small range enums"
	SHORT
	"For byte values, such as flags"
	BYTE
	"For double precision floating point numbers, such as precise financial calculations"
	DOUBLE
	"For single precision floating point numbers, such as general scientific calculations"
	FLOAT
	"For half precision floating point numbers, such as simple graphics processing"
	HALF_FLOAT
	"For scaled floating point numbers, such as amounts requiring precise decimal control"
	SCALED_FLOAT
	"For date and time, supports multiple date formats, default is ISO 8601"
	DATE
	"For boolean values, represents true or false"
	BOOLEAN
	"For storing IPv4 or IPv6 addresses"
	IP
}

enum SearchableAnalyzer {
	"Maximum word segmentation, splits into as many possible terms as possible"
	IK_MAX_WORD
	"Smart word segmentation, splits into more commonly used terms"
	IK_SMART
}