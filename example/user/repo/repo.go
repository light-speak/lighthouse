// Code generated by github.com/light-speak/lighthouse, DO NOT EDIT.
package repo

import (
  "sync"
  "github.com/light-speak/lighthouse/graphql/model"
  "gorm.io/gorm"
  "user/models"
  "github.com/light-speak/lighthouse/context"
)

func Load__User(ctx *context.Context, key int64, field string) (*sync.Map, error) {
  data, err := model.GetLoader[int64](model.GetDB(), "users", field).Load(key)
  if err != nil {
    return nil, err
  }
  syncMap := &sync.Map{}
  for k, v := range data {
    syncMap.Store(k, v)
  }
  return syncMap, nil
}

func LoadList__User(ctx *context.Context, key int64, field string) ([]*sync.Map, error) {
  datas, err := model.GetLoader[int64](model.GetDB(), "users", field).LoadList(key)
  if err != nil {
    return nil, err
  }
  result := make([]*sync.Map, len(datas))
  for i, data := range datas {
    syncMap := &sync.Map{}
    for k, v := range data {
      syncMap.Store(k, v)
    }
    result[i] = syncMap
  }
  return result, nil
}

func Query__User(scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return model.GetDB().Model(&models.User{}).Scopes(scopes...)
}

func First__User(ctx *context.Context, data *sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  var err error
  var mu sync.Mutex
  if data == nil {
    mapData := make(map[string]interface{})
    err = Query__User().Scopes(scopes...).First(&mapData).Error
    if err != nil {
      return nil, err
    }
    data = &sync.Map{}
    for k, v := range mapData {
      data.Store(k, v)
    }
  }
  
  result := &sync.Map{}
  data.Range(func(key, value interface{}) bool {
    k := key.(string)
    if fn := models.UserEnumFields(k); fn != nil {
      mu.Lock()
      result.Store(k, fn(value))
      mu.Unlock()
    } else {
      result.Store(k, value)
    }
    return true
  })
  return result, nil
}

func List__User(ctx *context.Context, datas []*sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  var err error
  if datas == nil {
    mapDatas := make([]map[string]interface{}, 0)
    err = Query__User().Scopes(scopes...).Find(&mapDatas).Error
    if err != nil {
      return nil, err
    }
    datas = make([]*sync.Map, len(mapDatas))
    for i, mapData := range mapDatas {
      syncMap := &sync.Map{}
      for k, v := range mapData {
        syncMap.Store(k, v)
      }
      datas[i] = syncMap
    }
  }
  return datas, nil
}

func Count__User(scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  var count int64
  err := Query__User().Scopes(scopes...).Count(&count).Error
  return count, err
}

func Load__Article(ctx *context.Context, key int64, field string) (*sync.Map, error) {
  data, err := model.GetLoader[int64](model.GetDB(), "articles", field).Load(key)
  if err != nil {
    return nil, err
  }
  syncMap := &sync.Map{}
  for k, v := range data {
    syncMap.Store(k, v)
  }
  return syncMap, nil
}

func LoadList__Article(ctx *context.Context, key int64, field string) ([]*sync.Map, error) {
  datas, err := model.GetLoader[int64](model.GetDB(), "articles", field).LoadList(key)
  if err != nil {
    return nil, err
  }
  result := make([]*sync.Map, len(datas))
  for i, data := range datas {
    syncMap := &sync.Map{}
    for k, v := range data {
      syncMap.Store(k, v)
    }
    result[i] = syncMap
  }
  return result, nil
}

func Query__Article(scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return model.GetDB().Model(&models.Article{}).Scopes(scopes...)
}

func First__Article(ctx *context.Context, data *sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  var err error
  var mu sync.Mutex
  if data == nil {
    mapData := make(map[string]interface{})
    err = Query__Article().Scopes(scopes...).First(&mapData).Error
    if err != nil {
      return nil, err
    }
    data = &sync.Map{}
    for k, v := range mapData {
      data.Store(k, v)
    }
  }

  result := &sync.Map{}
  data.Range(func(key, value interface{}) bool {
    k := key.(string)
    if fn := models.ArticleEnumFields(k); fn != nil {
      mu.Lock()
      result.Store(k, fn(value))
      mu.Unlock()
    } else {
      result.Store(k, value)
    }
    return true
  })
  return result, nil
}

func List__Article(ctx *context.Context, datas []*sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  var err error
  if datas == nil {
    mapDatas := make([]map[string]interface{}, 0)
    err = Query__Article().Scopes(scopes...).Find(&mapDatas).Error
    if err != nil {
      return nil, err
    }
    datas = make([]*sync.Map, len(mapDatas))
    for i, mapData := range mapDatas {
      syncMap := &sync.Map{}
      for k, v := range mapData {
        syncMap.Store(k, v)
      }
      datas[i] = syncMap
    }
  }
  return datas, nil
}

func Count__Article(scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  var count int64
  err := Query__Article().Scopes(scopes...).Count(&count).Error
  return count, err
}

func Load__Post(ctx *context.Context, key int64, field string) (*sync.Map, error) {
  data, err := model.GetLoader[int64](model.GetDB(), "posts", field).Load(key)
  if err != nil {
    return nil, err
  }
  syncMap := &sync.Map{}
  for k, v := range data {
    syncMap.Store(k, v)
  }
  return syncMap, nil
}

func LoadList__Post(ctx *context.Context, key int64, field string) ([]*sync.Map, error) {
  datas, err := model.GetLoader[int64](model.GetDB(), "posts", field).LoadList(key)
  if err != nil {
    return nil, err
  }
  result := make([]*sync.Map, len(datas))
  for i, data := range datas {
    syncMap := &sync.Map{}
    for k, v := range data {
      syncMap.Store(k, v)
    }
    result[i] = syncMap
  }
  return result, nil
}

func Query__Post(scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return model.GetDB().Model(&models.Post{}).Scopes(scopes...)
}

func First__Post(ctx *context.Context, data *sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  var err error
  var mu sync.Mutex
  if data == nil {
    mapData := make(map[string]interface{})
    err = Query__Post().Scopes(scopes...).First(&mapData).Error
    if err != nil {
      return nil, err
    }
    data = &sync.Map{}
    for k, v := range mapData {
      data.Store(k, v)
    }
  }

  result := &sync.Map{}
  data.Range(func(key, value interface{}) bool {
    k := key.(string)
    if fn := models.PostEnumFields(k); fn != nil {
      mu.Lock()
      result.Store(k, fn(value))
      mu.Unlock()
    } else {
      result.Store(k, value)
    }
    return true
  })
  return result, nil
}

func List__Post(ctx *context.Context, datas []*sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  var err error
  if datas == nil {
    mapDatas := make([]map[string]interface{}, 0)
    err = Query__Post().Scopes(scopes...).Find(&mapDatas).Error
    if err != nil {
      return nil, err
    }
    datas = make([]*sync.Map, len(mapDatas))
    for i, mapData := range mapDatas {
      syncMap := &sync.Map{}
      for k, v := range mapData {
        syncMap.Store(k, v)
      }
      datas[i] = syncMap
    }
  }
  return datas, nil
}

func Count__Post(scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  var count int64
  err := Query__Post().Scopes(scopes...).Count(&count).Error
  return count, err
}

func Load__Comment(ctx *context.Context, key int64, field string) (*sync.Map, error) {
  data, err := model.GetLoader[int64](model.GetDB(), "comments", field).Load(key)
  if err != nil {
    return nil, err
  }
  syncMap := &sync.Map{}
  for k, v := range data {
    syncMap.Store(k, v)
  }
  return syncMap, nil
}

func LoadList__Comment(ctx *context.Context, key int64, field string) ([]*sync.Map, error) {
  datas, err := model.GetLoader[int64](model.GetDB(), "comments", field).LoadList(key)
  if err != nil {
    return nil, err
  }
  result := make([]*sync.Map, len(datas))
  for i, data := range datas {
    syncMap := &sync.Map{}
    for k, v := range data {
      syncMap.Store(k, v)
    }
    result[i] = syncMap
  }
  return result, nil
}

func Query__Comment(scopes ...func(db *gorm.DB) *gorm.DB) *gorm.DB {
  return model.GetDB().Model(&models.Comment{}).Scopes(scopes...)
}

func First__Comment(ctx *context.Context, data *sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) (*sync.Map, error) {
  var err error
  var mu sync.Mutex
  if data == nil {
    mapData := make(map[string]interface{})
    err = Query__Comment().Scopes(scopes...).First(&mapData).Error
    if err != nil {
      return nil, err
    }
    data = &sync.Map{}
    for k, v := range mapData {
      data.Store(k, v)
    }
  }

  result := &sync.Map{}
  data.Range(func(key, value interface{}) bool {
    k := key.(string)
    if fn := models.CommentEnumFields(k); fn != nil {
      mu.Lock()
      result.Store(k, fn(value))
      mu.Unlock()
    } else {
      result.Store(k, value)
    }
    return true
  })
  return result, nil
}

func List__Comment(ctx *context.Context, datas []*sync.Map, scopes ...func(db *gorm.DB) *gorm.DB) ([]*sync.Map, error) {
  var err error
  if datas == nil {
    mapDatas := make([]map[string]interface{}, 0)
    err = Query__Comment().Scopes(scopes...).Find(&mapDatas).Error
    if err != nil {
      return nil, err
    }
    datas = make([]*sync.Map, len(mapDatas))
    for i, mapData := range mapDatas {
      syncMap := &sync.Map{}
      for k, v := range mapData {
        syncMap.Store(k, v)
      }
      datas[i] = syncMap
    }
  }
  return datas, nil
}

func Count__Comment(scopes ...func(db *gorm.DB) *gorm.DB) (int64, error) {
  var count int64
  err := Query__Comment().Scopes(scopes...).Count(&count).Error
  return count, err
}

func init() {
  model.AddQuickFirst("User", First__User)
  model.AddQuickList("User", List__User)
  model.AddQuickLoad("User", Load__User)
  model.AddQuickLoadList("User", LoadList__User)
  model.AddQuickCount("User", Count__User)
  model.AddQuickFirst("Article", First__Article)
  model.AddQuickList("Article", List__Article)
  model.AddQuickLoad("Article", Load__Article)
  model.AddQuickLoadList("Article", LoadList__Article)
  model.AddQuickCount("Article", Count__Article)
  model.AddQuickFirst("Post", First__Post)
  model.AddQuickList("Post", List__Post)
  model.AddQuickLoad("Post", Load__Post)
  model.AddQuickLoadList("Post", LoadList__Post)
  model.AddQuickCount("Post", Count__Post)
  model.AddQuickFirst("Comment", First__Comment)
  model.AddQuickList("Comment", List__Comment)
  model.AddQuickLoad("Comment", Load__Comment)
  model.AddQuickLoadList("Comment", LoadList__Comment)
  model.AddQuickCount("Comment", Count__Comment)
}
